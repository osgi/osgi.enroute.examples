/*******************************************************************************
 * Copyright (C) 2015 - OSGi Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package osgi.enroute.examples.led.controller.mqtt.provider;

import static java.util.Objects.isNull;
import static java.util.Objects.nonNull;
import static org.osgi.service.component.annotations.ReferenceCardinality.OPTIONAL;
import static org.osgi.service.log.LogService.LOG_DEBUG;
import static org.osgi.service.log.LogService.LOG_ERROR;
import static org.osgi.service.log.LogService.LOG_INFO;
import static osgi.enroute.examples.led.controller.util.Utils.dictionaryToMap;

import java.io.IOException;
import java.net.URISyntaxException;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import org.fusesource.hawtbuf.Buffer;
import org.fusesource.hawtbuf.UTF8Buffer;
import org.fusesource.mqtt.client.Callback;
import org.fusesource.mqtt.client.CallbackConnection;
import org.fusesource.mqtt.client.Listener;
import org.fusesource.mqtt.client.MQTT;
import org.fusesource.mqtt.client.QoS;
import org.fusesource.mqtt.client.Topic;
import org.osgi.service.cm.Configuration;
import org.osgi.service.cm.ConfigurationAdmin;
import org.osgi.service.cm.ConfigurationEvent;
import org.osgi.service.cm.ConfigurationListener;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.log.LogService;
import org.osgi.service.metatype.annotations.Designate;

import osgi.enroute.examples.led.controller.mqtt.api.IMqttClient;
import osgi.enroute.examples.led.controller.mqtt.api.MessageListener;
import osgi.enroute.examples.led.controller.mqtt.configurable.MqttConfiguration;

/**
 * Implementation of {@link IMqttClient}
 */
@Designate(ocd = MqttConfiguration.class)
@Component(name = "osgi.enroute.examples.led.controller.mqtt")
public final class MqttClient implements IMqttClient, ConfigurationListener {

	/**
	 * MQTT Server
	 */
	private static String host;

	/**
	 * MQTT Configuration Service PID
	 */
	private static final String MQTT_CONF_PID = "osgi.enroute.examples.led.controller.mqtt";

	/**
	 * MQTT Password
	 */
	private static String password;

	/**
	 * MQTT Port
	 */
	private static int port = DEFAULT_MQTT_PORT;

	/**
	 * MQTT Username
	 */
	private static String username;

	/**
	 * list of listeners
	 */
	protected Map<String, MessageListener> channels = null;

	/**
	 * Configuration Admin Service Reference
	 */
	@Reference
	private volatile ConfigurationAdmin configurationAdmin;

	/**
	 * Callback connection reference for subscription
	 */
	protected CallbackConnection connection = null;

	/**
	 * The lock to be used on the created object
	 */
	private Lock connectionLock;

	/**
	 * The error message generated by the client
	 */
	private String errorMsg;

	/**
	 * Holder to check whether the client is connected
	 */
	private boolean isConnected;

	/**
	 * Log Service Reference
	 */
	@Reference(cardinality = OPTIONAL)
	private volatile LogService logService;

	/**
	 * MQTT Configuration
	 */
	private Configuration mqttConfiguration;

	/**
	 * Activation Callback
	 */
	@Activate
	public void activate() throws IOException {
		this.connectionLock = new ReentrantLock();
		if (nonNull(this.configurationAdmin)) {
			this.mqttConfiguration = this.configurationAdmin.getConfiguration(MQTT_CONF_PID);
		}
	}

	/** {@inheritDoc}} */
	@Override
	public void configurationEvent(final ConfigurationEvent event) {
		if (MQTT_CONF_PID.equals(event.getPid())) {
			final Dictionary<String, ?> properties = this.mqttConfiguration.getProperties();
			this.extractConfiguration(properties);
		}
	}

	/** {@inheritDoc} */
	@Override
	public boolean connect() {

		// Actual MQTT Object created
		final MQTT mqtt = new MQTT();

		try {
			if (isNull(MqttClient.host)) {
				return false;
			}

			mqtt.setHost(this.hostToURI(MqttClient.host, String.valueOf(MqttClient.port)));
			mqtt.setClientId(CLIENT_ID);

			if (nonNull(MqttClient.password)) {
				mqtt.setPassword(String.valueOf(MqttClient.password));
			}
			if (nonNull(MqttClient.username)) {
				mqtt.setUserName(String.valueOf(MqttClient.username));
			}

		} catch (final URISyntaxException e) {
			this.logService.log(LOG_ERROR, e.getMessage());
		}
		try {
			if (this.connectionLock.tryLock(5, TimeUnit.SECONDS)) {
				this.safelyConnect(mqtt);
			}
			this.isConnected = true;
		} catch (final InterruptedException e) {
			this.isConnected = false;
		} catch (final ConnectionException e) {
			this.isConnected = false;
		} finally {
			this.connectionLock.unlock();
		}
		return this.isConnected;
	}

	/** {@inheritDoc} */
	@Deactivate
	@Override
	public void disconnect() {
		try {
			if (this.connectionLock.tryLock(5, TimeUnit.SECONDS)) {
				this.safelyDisconnect();
			}
		} catch (final Exception e) {
			this.logService.log(LOG_DEBUG, "Exception while disconnecting");
		}
	}

	/**
	 * Connection Exception triggerer
	 */
	private void exceptionOccurred(final String message) throws ConnectionException {
		throw new ConnectionException(message);
	}

	/**
	 * Extracts Configuration Parameters
	 */
	private void extractConfiguration(final Dictionary<String, ?> properties) {
		final Map<String, ?> map = dictionaryToMap(properties);

		// MQTT Password Check
		if (map.containsKey("userPassword")) {
			final Object password = map.get("userPassword");
			if (nonNull(password)) {
				if (!isNull(String.valueOf(password)) || (String.valueOf(password).length() == 0)) {
					MqttClient.password = String.valueOf(password);
				}
			}
		}

		// MQTT Port Check
		if (map.containsKey("port")) {
			final Object port = map.get("port");
			if (nonNull(port)) {
				if (!isNull(String.valueOf(port)) || (String.valueOf(port).length() == 0)) {
					MqttClient.port = Integer.valueOf(port.toString());
				}
			}
		}

		// MQTT Username Check
		if (map.containsKey("username")) {
			final Object username = map.get("username");
			if (nonNull(username)) {
				if (!isNull(String.valueOf(username)) || (String.valueOf(username).length() == 0)) {
					MqttClient.username = String.valueOf(username);
				}
			}
		}

		// MQTT Host Server Check
		if (map.containsKey("host")) {
			final Object host = map.get("host");
			if (nonNull(host)) {
				if (!isNull(String.valueOf(host)) || (String.valueOf(host).length() == 0)) {
					MqttClient.host = String.valueOf(host);
				}
			}
		}
	}

	/** {@inheritDoc} */
	@Override
	public String getClientId() {
		return CLIENT_ID;
	}

	/** {@inheritDoc} */
	@Override
	public String getHost() {
		return host;
	}

	/** {@inheritDoc} */
	@Override
	public Set<String> getSubscribedChannels() {
		return this.channels.keySet();
	}

	/**
	 * Returns the MQTT URI Scheme
	 */
	private String hostToURI(final String host, final String port) {
		return PROTOCOL + "://" + host + ":" + port;
	}

	/** {@inheritDoc} */
	@Override
	public boolean isConnected() {
		return this.isConnected;
	}

	/** {@inheritDoc} */
	@Override
	public void publish(final String channel, final String payload) {
		if (this.connection != null) {
			this.connection.publish(channel, payload.getBytes(), QoS.AT_MOST_ONCE, false, new Callback<Void>() {
				/** {@inheritDoc} */
				@Override
				public void onFailure(final Throwable throwable) {
					MqttClient.this.logService.log(LOG_DEBUG, "Impossible to publish message to channel " + channel);
				}

				/** {@inheritDoc} */
				@Override
				public void onSuccess(final Void aVoid) {
					MqttClient.this.logService.log(LOG_DEBUG, "Successfully published");
				}
			});
		}
	}

	/**
	 * Connect in a thread safe manner
	 */
	private void safelyConnect(final MQTT mqtt) throws ConnectionException {
		if (this.isConnected) {
			this.disconnect();
		}
		// Initialize channels
		this.channels = new HashMap<>();
		// Register callbacks
		this.connection = mqtt.callbackConnection();
		this.connection.listener(new Listener() {
			/** {@inheritDoc} */
			@Override
			public void onConnected() {
				MqttClient.this.logService.log(LOG_DEBUG, "Host connected");
			}

			/** {@inheritDoc} */
			@Override
			public void onDisconnected() {
				MqttClient.this.logService.log(LOG_DEBUG, "Host disconnected");
			}

			/** {@inheritDoc} */
			@Override
			public void onFailure(final Throwable throwable) {
				MqttClient.this.logService.log(LOG_DEBUG, "Exception Occurred: " + throwable.getMessage());
			}

			/** {@inheritDoc} */
			@Override
			public void onPublish(final UTF8Buffer mqttChannel, final Buffer mqttMessage, final Runnable ack) {
				if (MqttClient.this.channels.containsKey(mqttChannel.toString())) {

					try {
						MqttClient.this.channels.get(mqttChannel.toString())
								.processMessage(new String(mqttMessage.toByteArray(), "UTF-8"));
					} catch (final IOException e) {
						MqttClient.this.logService.log(LOG_DEBUG, "I/O Exception Occurred: " + e.getMessage());
					}
				}
				ack.run();
			}
		});
		// Connect to broker in a blocking fashion
		final CountDownLatch l = new CountDownLatch(1);
		this.connection.connect(new Callback<Void>() {
			/** {@inheritDoc} */
			@Override
			public void onFailure(final Throwable throwable) {
				MqttClient.this.errorMsg = "Impossible to CONNECT to the MQTT server, terminating";
				MqttClient.this.logService.log(LOG_ERROR, MqttClient.this.errorMsg);
			}

			/** {@inheritDoc} */
			@Override
			public void onSuccess(final Void aVoid) {
				l.countDown();
				MqttClient.this.logService.log(LOG_INFO, "Successfully Connected to Host");
			}

		});
		try {
			if (!l.await(5, TimeUnit.SECONDS)) {
				this.errorMsg = "Impossible to CONNECT to the MQTT server: TIMEOUT. Terminating";
				this.logService.log(LOG_ERROR, this.errorMsg);
				this.exceptionOccurred(this.errorMsg);
			}
		} catch (final InterruptedException e) {
			this.errorMsg = "\"Impossible to CONNECT to the MQTT server, terminating\"";
			this.logService.log(LOG_ERROR, this.errorMsg);
			this.exceptionOccurred(this.errorMsg);

		}
	}

	/**
	 * Disconnects the client in a thread safe way
	 */
	private void safelyDisconnect() {
		if (this.connection != null) {
			this.connection.disconnect(new Callback<Void>() {
				/** {@inheritDoc} */
				@Override
				public void onFailure(final Throwable throwable) {
					MqttClient.this.logService.log(LOG_ERROR, "Error while disconnecting");
				}

				/** {@inheritDoc} */
				@Override
				public void onSuccess(final Void aVoid) {
					MqttClient.this.logService.log(LOG_INFO, "Successfully disconnected");
				}
			});
		}
	}

	/** {@inheritDoc} */
	@Override
	public void subscribe(final String channel, final MessageListener callback) {
		if (this.connection != null) {
			if (this.channels.containsKey(channel)) {
				return;
			}
			final CountDownLatch l = new CountDownLatch(1);
			final Topic[] topic = { new Topic(channel, QoS.AT_MOST_ONCE) };
			this.connection.subscribe(topic, new Callback<byte[]>() {
				/** {@inheritDoc} */
				@Override
				public void onFailure(final Throwable throwable) {
					MqttClient.this.logService.log(LOG_ERROR, "Impossible to SUBSCRIBE to channel \"" + channel + "\"");
					l.countDown();
				}

				/** {@inheritDoc} */
				@Override
				public void onSuccess(final byte[] bytes) {
					MqttClient.this.channels.put(channel, callback);
					l.countDown();
					MqttClient.this.logService.log(LOG_INFO, "Successfully subscribed to " + channel);
				}
			});
			try {
				l.await();
			} catch (final InterruptedException e) {
				this.logService.log(LOG_ERROR, "Impossible to SUBSCRIBE to channel \"" + channel + "\"");
			}
		}
	}

	/** {@inheritDoc} */
	@Override
	public void unsubscribe(final String channel) {
		if (nonNull(this.connection)) {
			this.channels.remove(channel);
			final UTF8Buffer[] topic = { UTF8Buffer.utf8(channel) };
			this.connection.unsubscribe(topic, new Callback<Void>() {
				/** {@inheritDoc} */
				@Override
				public void onFailure(final Throwable throwable) {
					MqttClient.this.logService.log(LOG_ERROR,
							"Exception occurred while unsubscribing: " + throwable.getMessage());
				}

				/** {@inheritDoc} */
				@Override
				public void onSuccess(final Void aVoid) {
					MqttClient.this.logService.log(LOG_DEBUG, "Successfully unsubscribed");
				}
			});
		}
	}
}
